<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[构建自动化工作流]]></title>
    <url>%2F2018%2F01%2F28%2Fnode%2F</url>
    <content type="text"><![CDATA[兩個問題学习目标 了解什么是Node，什么是NPM；（Node.js） 掌握Bower的使用； 熟练使用Less/Sass； 搭建一个自己的自动化工作流环境； 自动编译 自动合并 自动刷新 自动部署 GIT 与 GITHUB master 托管源文件 gh-pages 托管部署文件 在github搭建自己的blog 为什么要有自动化的流程 在我们的开发过程中有大量的重复操作 DRY Don’t repeat yourself 开发人员的精力应放在哪？创造，新的一切 前端开发的编译操作 1.Node环境1.1.什么是Node Node.js 可能类似jquery.js 不是JS文件，也不是一个JS框架（） 而是Server side Javascript runtime, 服务端的一个JS运行时 我们可以在NODE运行JS代码 alert();ECMAScript JS- ES BOM DOM node中只能运行ECMAScript，无法使用 BOM 和 DOM 目前我们的JS是运行在浏览器内核中 PHP是什么？是一门脚本语言也是一个运行环境 为什么Node选中了JS， 说到底就是一个JS运行环境 目前有两个分支 Node.js 0.12.7 官方版本 要求尽善尽美 IO.js 是社区的产物，不是官方的东西，io.js有很多新特性，迭代非常快，社区推进非常快 15年两者合并，发布node第一个正式版 4.0， 迭代速度又慢了 node 5.x == io.js node 4.0 == node 1.2.Node环境搭建1.2.1.Mac 安装包的方式 pkg NVM（Node Version Manager） 1234$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash$ echo '. ~/.nvm/nvm.sh' &gt;&gt; .bash_profile$ nvm install stable$ nvm alias default stable 1.2.2.Windows 安装包的方式 msi_x64 msi_x86 NVM（Node Version Manager） nvm(node version manager) 因为NODE版本比较多，开发人员可能依赖很多版本 通过NVM，可以轻松切换于不同的版本之间 1 NVM_HOME=C:\Develop\nvm NVM_SYMLINK=C:\Develop\nodejs NPM_HOME=C:\Develop\nvm\npm PATH=%NVM_HOME%;%NVM_SYMLINK%;%NPM_HOME% 1.2.3.环境变量 环境变量就是操作系统提供的系统级别用于存储变量的地方 系统变量和用户变量 系统变量指的是所用当前系统用户共享的变量 自己的电脑一般只有一个用户 建议将自己配置的环境变量放在用户变量中，用户变量比较干净 环境变量的变量名是不区分大小写的 变量间运行相互引用 特殊值： PATH变量（不区分大小写） PATH 相当于一个路径的引用 只要添加到PATH变量中的路径，都可以在任何目录下搜索 命令行 可以用来执行当前目录下的文件 命令 cd :change directory Node.js是一个轻内核（本身没有什么功能）的东东，所有的功能都要功能包提供 node官方提供了一些最基础的包 1.3.Node用途REPL环境（控制台环境）1.3.1.开发Web应用程序 做动态网站 开发提供数据的服务端API 1.3.2.前端开发工具基础 Node.js给前端乃至整个开发行业带来一场工业革命 刀跟火种 1.4.Node开发Web应用Demo1.4.1.复习请求与响应客户端发送到服务端的东西称之为请求报文服务端返回给客户端的东西称之为响应报文 1.5.NPM1.5.1.什么是NPMhttps://www.npmjs.com/ Node Package Manager Node应用程序依赖包的管理工具 安装卸载更新之类的操作 1.5.2.为什么使用NPM 包很多 场景：我需要用一个A，A依赖B，B依赖C 常见的包管理工具都有循环依赖的功能 你只需记住你要什么东西 1.5.3.常见的NPM操作// 安装一个包，默认安装最新稳定版本npm install package_name// –save// 初始化操作，给项目添加一个配置文件npm init// –yes参数走默认配置 如果官方数据源太慢使用 https://npm.taobao.org/ 2.Bower2.1.什么是Bower 官网 web应用程序依赖项管理工具 2.2.为什么使用Bower 方便便捷的方式管理包，zhuangbi 2.3.Bower实践 npm install -g bower // -g:global 修改npm全局路径，就是在用户目录下添加.npmrc文件 3.Sass/LESS 4.Gulp4.1.Gulp简介 链接： 官网 中文网 就是用来机械化的完成重复性质的工作 gulp的机制就是将重复工作抽象成一个个的任务， 4.2.Gulp准备工作 安装Node.js 安装 gulp 命令行工具 npm install -g gulp 初始化 gulp 项目 创建任务 - gulpfile.js 4.3.基本使用4.4.常用插件 编译 Less：gulp-less 创建本地服务器：gulp-connect 合并文件：gulp-concat 最小化 js 文件：gulp-uglify 重命名文件：gulp-rename 最小化 css 文件：gulp-minify-css 压缩html文件 gulp-minify-html 最小化图像：gulp-imagemin 5.Git5.1.什么是GIT，什么是GITHUB GIT GITHUB 5.2.环境安装5.3.GIT常用命令 6.Markdownhttps://guides.github.com/features/mastering-markdown/https://help.github.com/articles/github-flavored-markdown/https://help.github.com/articles/markdown-basics/]]></content>
  </entry>
  <entry>
    <title><![CDATA[模块化开发]]></title>
    <url>%2F2018%2F01%2F13%2Fmodule%2F</url>
    <content type="text"><![CDATA[概述为什么使用模块化开发 业务发展 -&gt; 代码量变大,难以维护 -&gt; 拆分代码成多个文件 -&gt; 将特定功能的代码放在一个文件（即模块）中； 要解决的问题 避免命名冲突和变量污染 解决方案1、前缀命名空间: 能够有效解决，但却定义了大量的全局变量2、对象命名空间：3、IIFE： 管理模块依赖当引入的多个模块间存在相互依赖关系时，自动分析依赖、处理依赖关系，不需要手动维护 规范CommonJS规范 文件即模块 使用 module.exports / exports 暴露对外接口 使用 require 同步加载模块依赖 适用范围： 适合：node 服务端，文件存在本地硬盘 -&gt; 加载快，可以同步加载 不适合：浏览器端，文件需要通过网络加载 -&gt; 耗时，同步加载阻塞页面（需要异步加载所需模块）-&gt; AMD规范 AMD规范 Asynchronous Module Definition 规范 CMD规范 Common Module Definition 规范 对比 AMD 与 CMD这两个现在都不常用，了解就好。 声明依赖模块时机不同 AMD 推崇依赖前置，在定义模块时就要声明其以来模块 CMD 推崇依赖就近，需要用时再 require() 1234567891011//CMDdefine(function(require, exports, module) &#123; var a = require(&apos;./a&apos;); a.doSomething();&#125;) //AMDdefine([&apos;./a&apos;, &apos;./b&apos;], function() &#123; a.doSomething(); b.doSomething();&#125;) AMD的使用(require.js) define(‘模块标识’, ‘要依赖的模块’, ‘调用该模块要执行的函数’) 定义模块 reuqire(‘模块名’, ‘回调函数’) 调用模块 123456789101112131415161718192021//定义 moduleAdefine(&apos;moduleA&apos;, function(require, exports, module) &#123; exports.getNum = function() &#123; return 5; &#125;;&#125;);//定义moduleDdefine(&apos;moduleD&apos;, [&apos;moduleA&apos;], function(moduleA) &#123; var index = moduleA.getNum(); return &#123; addIndex: function() &#123; index += 1; &#125; &#125;&#125;)//使用模块require(&apos;moduleD&apos;, function(moduleD) &#123;&#125;); CMD的使用(sea.js) 引入 SeaJS 的库 定义模块（define） 暴露模块接口（exports） 加载依赖模块（require） 12345678&lt;script src=&quot;./sea.js&quot;&gt;&lt;/script&gt;&lt;script&gt; define(function (require,exports,module) &#123; // exports : 对外的接口 // requires : 依赖的模块 require(&apos;./a.js&apos;);//如果地址是一个模块的话，那么require的返回值就是模块中的exports &#125;);&lt;/script&gt; ES6 模块标准设计思想一个JS文件就代表一个模块，你可以使用 import 和 export 来导入/导出模块中的东西 基本特点 自动开启严格模式，即使你没有写 use strict 每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等 每一个模块只加载一次，每一个 JS 只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取。 一个模块就是一个单例，或者说就是一个对象 更多 ES6模块指南 ES6入门之Module语法]]></content>
      <categories>
        <category>性能与工程化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpacrk入门总结]]></title>
    <url>%2F2017%2F06%2F06%2Fwebpacrk%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[什么是webpack webpakc可以看作是一个模块打包机,可以分析你的项目结构,帮你自动处理一些文件,如压缩、转化等,最终转化为适合浏览器使用的格式。 webpack与gulp工作方式的区别gulp:在一个配置文件中,指明对某些文件进行一些操作(编译,组合,压缩等)步骤之后,这个工具可以自动帮你处理这些文件 工作流程如下 webpack:通过指定的一个入口文件,webpack会从这个文件开始找到你项目所有的依赖文件,使用loaders处理它们,最后打包成一个浏览器可识别的JS(bundle.js)文件 工作流程如下 webpack的使用安装1234//全局安装npm install -g webpack//安装到你的项目目录npm instakk --save-dev webpack 假设项目结构如图所示 执行webpack的几种方法 终端输入 12345webpack entry file(入口文件的位置) bundled file(存放生成的bundle.js的位置) //按上面项目结构走//webpack非全局安装时(全局安装时可省略node_modules/.bin)node_modules/.bin/webpack app/main.js public/bundle.js 通过配置文件来使用webpack 在项目的根目录下建一个名为webpack.config.js的配置文件(本质上是一个JS模块),可以把所有与构建相关的信息放在里面 1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 通过配置package.json文件使用webpack 1234567891011121314&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot;, &quot;comment&quot;: &quot;相当于把npm的start命令指向webpack&quot; &#125;, &quot;author&quot;: &quot;Silence_JK&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^2.6.1&quot; &#125;&#125; 注：package.json中的脚本部分已默认在命令前添加node_modules/.bin,So don’t worry是否在全局安装了webpack webpack的一些常用功能 生成Source Maps(报错时方便调试,google浏览器中setting-&gt;勾选Enalbe JS source map),在wepack的配置文件中配置devtool选项即可 devtoo选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度； cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项； cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； loaders 通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如将JSON文件转换为JavaScript文件,将下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件,对React的开发而言,合适的Loaders可以把React的JSX文件转换为JS文件。 loaders需要单独安装并且要在webpack.config.js下的module下配置常用配置项包括以下几个: test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 例如:1234567891011121314151617181920212223242526272829//安装可以转换JSON的loadernpm install --save-dev json-loader//配置module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123;//在配置文件里添加JSON loader loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 插件(Plugins)插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins是完全不同的东西 loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个 插件并不直接操作单个文件，它直接对整个构建过程其作用。 Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。 使用插件的方法 要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续看例子，我们添加了一个实现版权声明的插件1234567891011121314151617181920//webpack.config.jsvar webpack = require(&apos;webpack&apos;);module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123;...&#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, plugins: [ new webpack.BannerPlugin(&quot;Copyright Flying Unicorns inc.&quot;)//在这个数组中new一个就可以了 ], devServer: &#123;...&#125;&#125; 查看使用此插件后的JS打包文件localhost:8080/bundle.js 参考文章: 入门webpack,看这篇就够了]]></content>
  </entry>
</search>
