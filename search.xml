<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[工程化]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[工程化（What &amp; Why）为了方便代码维护，我们要将相同功能的函数、对象等放入一个文件（模块），这样就会形成很多文件；但为了提高浏览器的渲染速度，我们又要尽量减少网络中请求的文件数； 既要考虑性能，又要考虑模块化，相互矛盾，怎么搞？ 解决办法：开发时一套代码，发布到线上时一套合并压缩的代码。 如果手动处理，费时费力，于是就提出工程化。 工程化的实现grunt最早出现，每次操作都是文件读写，慢！配置相对繁琐。 gulp基于grunt缺点做得改进，基于文件流读写，快！配置也相对简单。 webpack早期只是一个打包工具，作为gulp的插件来使用；现在发展的相对全面，有以下特点： 任何文件都可以当模块 打包体积更小 打包更快 默认支持 AMD，Commonjs，ES6 modules webpack使用添加配置文件 webpack.config.js123456789101112131415var path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/js/index.js&apos;, //入口文件 output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;./dist&apos;) //文件处理后的输出目录 &#125;, module: &#123; &#125;, plugins: [ ]&#125; module 模块主要是针对特定类型的单文件进行处理 css-loader .css -&gt; 可以加载的模块 babel-loader .es6 -&gt; .js scss-loader .scss -&gt; .css 在上面代码基础上增加打包css文件功能 npm 安装 style-loader 和 css-loader 模块 增加打包 css 的配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/js/index.js&apos;, //入口文件 output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;./dist&apos;) //文件处理后的输出目录 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125; ] &#125;, plugins: [ ]&#125;``` ### plugins 模块来完成 loader 模块无法完成的事,比如：- 压缩js- 压缩图片- 单独分离出css文件- ...在上面代码基础上实现压缩js功能- npm 安装 uglifyjs-webpack-plugin- 增加插件配置```(javascript)var path = require(&apos;path&apos;);//插件一般都是返回一个类，用时用 newvar UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);module.exports = &#123; entry: &apos;./src/js/index.js&apos;, output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;./dist&apos;) &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;, ] &#125;, plugins: [ new UglifyJsPlugin() ]&#125; 自动刷新本地开发流程保存代码 -&gt; webpack构建 -&gt; 刷新浏览器webpack-dev-server 可以自动完成这个过程与服务端 node 的 node-supervisior 类似 操作步骤： 先用 npm 安装 html-wepack-plugin 插件，将 index.html 也加入构建 将 index.html 从根目录移至 src，并删除其中 script 及 link 标签 在 webpack.config.js 中配置该插件 此时所有html,css,js源代码都在 src 目录下，打包后的文件都在 dist 目录下 全局安装 webpack-dev-server 运行 webpack-dev-server –open，修改 src 下文件，看是否自动刷新]]></content>
      <categories>
        <category>性能与工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发]]></title>
    <url>%2F2018%2F01%2F13%2F%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[概述为什么使用模块化开发 业务发展 -&gt; 代码量变大,难以维护 -&gt; 拆分代码成多个文件 -&gt; 将特定功能的代码放在一个文件（即模块）中； 要解决的问题 避免命名冲突和变量污染 解决方案1、前缀命名空间: 能够有效解决，但却定义了大量的全局变量2、对象命名空间：3、IIFE： 管理模块依赖当引入的多个模块间存在相互依赖关系时，自动分析依赖、处理依赖关系，不需要手动维护 规范CommonJS规范 文件即模块 使用 module.exports / exports 暴露对外接口 使用 require 同步加载模块依赖 适用范围： 适合：node 服务端，文件存在本地硬盘 -&gt; 加载快，可以同步加载 不适合：浏览器端，文件需要通过网络加载 -&gt; 耗时，同步加载阻塞页面（需要异步加载所需模块）-&gt; AMD规范 AMD规范 Asynchronous Module Definition 规范 CMD规范 Common Module Definition 规范 对比 AMD 与 CMD这两个现在都不常用，了解就好。 声明依赖模块时机不同 AMD 推崇依赖前置，在定义模块时就要声明其以来模块 CMD 推崇依赖就近，需要用时再 require() 1234567891011//CMDdefine(function(require, exports, module) &#123; var a = require(&apos;./a&apos;); a.doSomething();&#125;) //AMDdefine([&apos;./a&apos;, &apos;./b&apos;], function() &#123; a.doSomething(); b.doSomething();&#125;) AMD的使用(require.js) define(‘模块标识’, ‘要依赖的模块’, ‘调用该模块要执行的函数’) 定义模块 reuqire(‘模块名’, ‘回调函数’) 调用模块 123456789101112131415161718192021//定义 moduleAdefine(&apos;moduleA&apos;, function(require, exports, module) &#123; exports.getNum = function() &#123; return 5; &#125;;&#125;);//定义moduleDdefine(&apos;moduleD&apos;, [&apos;moduleA&apos;], function(moduleA) &#123; var index = moduleA.getNum(); return &#123; addIndex: function() &#123; index += 1; &#125; &#125;&#125;)//使用模块require(&apos;moduleD&apos;, function(moduleD) &#123;&#125;); CMD的使用(sea.js) 引入 SeaJS 的库 定义模块（define） 暴露模块接口（exports） 加载依赖模块（require） 12345678&lt;script src=&quot;./sea.js&quot;&gt;&lt;/script&gt;&lt;script&gt; define(function (require,exports,module) &#123; // exports : 对外的接口 // requires : 依赖的模块 require(&apos;./a.js&apos;);//如果地址是一个模块的话，那么require的返回值就是模块中的exports &#125;);&lt;/script&gt; ES6 模块标准设计思想一个JS文件就代表一个模块，你可以使用 import 和 export 来导入/导出模块中的东西 基本特点 自动开启严格模式，即使你没有写 use strict 每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等 每一个模块只加载一次，每一个 JS 只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取。 一个模块就是一个单例，或者说就是一个对象 更多 ES6模块指南 ES6入门之Module语法]]></content>
      <categories>
        <category>性能与工程化</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpacrk入门总结]]></title>
    <url>%2F2017%2F06%2F06%2Fwebpacrk%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[更新（2018.01.29）：这篇写的不够好，请看另一篇有关webpack的：”工程化“ 什么是webpack webpakc可以看作是一个模块打包机,可以分析你的项目结构,帮你自动处理一些文件,如压缩、转化等,最终转化为适合浏览器使用的格式。 webpack与gulp工作方式的区别gulp:在一个配置文件中,指明对某些文件进行一些操作(编译,组合,压缩等)步骤之后,这个工具可以自动帮你处理这些文件 工作流程如下 webpack:通过指定的一个入口文件,webpack会从这个文件开始找到你项目所有的依赖文件,使用loaders处理它们,最后打包成一个浏览器可识别的JS(bundle.js)文件 工作流程如下 webpack的使用安装1234//全局安装npm install -g webpack//安装到你的项目目录npm instakk --save-dev webpack 假设项目结构如图所示 执行webpack的几种方法 终端输入 12345webpack entry file(入口文件的位置) bundled file(存放生成的bundle.js的位置) //按上面项目结构走//webpack非全局安装时(全局安装时可省略node_modules/.bin)node_modules/.bin/webpack app/main.js public/bundle.js 通过配置文件来使用webpack 在项目的根目录下建一个名为webpack.config.js的配置文件(本质上是一个JS模块),可以把所有与构建相关的信息放在里面 1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 通过配置package.json文件使用webpack 1234567891011121314&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot;, &quot;comment&quot;: &quot;相当于把npm的start命令指向webpack&quot; &#125;, &quot;author&quot;: &quot;Silence_JK&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^2.6.1&quot; &#125;&#125; 注：package.json中的脚本部分已默认在命令前添加node_modules/.bin,So don’t worry是否在全局安装了webpack webpack的一些常用功能 生成Source Maps(报错时方便调试,google浏览器中setting-&gt;勾选Enalbe JS source map),在wepack的配置文件中配置devtool选项即可 devtoo选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度； cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项； cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； loaders 通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如将JSON文件转换为JavaScript文件,将下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件,对React的开发而言,合适的Loaders可以把React的JSX文件转换为JS文件。 loaders需要单独安装并且要在webpack.config.js下的module下配置常用配置项包括以下几个: test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 例如:1234567891011121314151617181920212223242526272829//安装可以转换JSON的loadernpm install --save-dev json-loader//配置module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123;//在配置文件里添加JSON loader loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 插件(Plugins)插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins是完全不同的东西 loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个 插件并不直接操作单个文件，它直接对整个构建过程其作用。 Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。 使用插件的方法 要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续看例子，我们添加了一个实现版权声明的插件1234567891011121314151617181920//webpack.config.jsvar webpack = require(&apos;webpack&apos;);module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123;...&#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, plugins: [ new webpack.BannerPlugin(&quot;Copyright Flying Unicorns inc.&quot;)//在这个数组中new一个就可以了 ], devServer: &#123;...&#125;&#125; 查看使用此插件后的JS打包文件localhost:8080/bundle.js 参考文章: 入门webpack,看这篇就够了]]></content>
      <categories>
        <category>性能与工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
