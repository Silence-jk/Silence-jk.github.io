<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[构建自动化工作流]]></title>
    <url>%2F2018%2F01%2F28%2Fnode%2F</url>
    <content type="text"><![CDATA[兩個問題学习目标 了解什么是Node，什么是NPM；（Node.js） 掌握Bower的使用； 熟练使用Less/Sass； 搭建一个自己的自动化工作流环境； 自动编译 自动合并 自动刷新 自动部署 GIT 与 GITHUB master 托管源文件 gh-pages 托管部署文件 在github搭建自己的blog 为什么要有自动化的流程 在我们的开发过程中有大量的重复操作 DRY Don’t repeat yourself 开发人员的精力应放在哪？创造，新的一切 前端开发的编译操作 1.Node环境1.1.什么是Node Node.js 可能类似jquery.js 不是JS文件，也不是一个JS框架（） 而是Server side Javascript runtime, 服务端的一个JS运行时 我们可以在NODE运行JS代码 alert();ECMAScript JS- ES BOM DOM node中只能运行ECMAScript，无法使用 BOM 和 DOM 目前我们的JS是运行在浏览器内核中 PHP是什么？是一门脚本语言也是一个运行环境 为什么Node选中了JS， 说到底就是一个JS运行环境 目前有两个分支 Node.js 0.12.7 官方版本 要求尽善尽美 IO.js 是社区的产物，不是官方的东西，io.js有很多新特性，迭代非常快，社区推进非常快 15年两者合并，发布node第一个正式版 4.0， 迭代速度又慢了 node 5.x == io.js node 4.0 == node 1.2.Node环境搭建1.2.1.Mac 安装包的方式 pkg NVM（Node Version Manager） 1234$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash$ echo '. ~/.nvm/nvm.sh' &gt;&gt; .bash_profile$ nvm install stable$ nvm alias default stable 1.2.2.Windows 安装包的方式 msi_x64 msi_x86 NVM（Node Version Manager） nvm(node version manager) 因为NODE版本比较多，开发人员可能依赖很多版本 通过NVM，可以轻松切换于不同的版本之间 1 NVM_HOME=C:\Develop\nvm NVM_SYMLINK=C:\Develop\nodejs NPM_HOME=C:\Develop\nvm\npm PATH=%NVM_HOME%;%NVM_SYMLINK%;%NPM_HOME% 1.2.3.环境变量 环境变量就是操作系统提供的系统级别用于存储变量的地方 系统变量和用户变量 系统变量指的是所用当前系统用户共享的变量 自己的电脑一般只有一个用户 建议将自己配置的环境变量放在用户变量中，用户变量比较干净 环境变量的变量名是不区分大小写的 变量间运行相互引用 特殊值： PATH变量（不区分大小写） PATH 相当于一个路径的引用 只要添加到PATH变量中的路径，都可以在任何目录下搜索 命令行 可以用来执行当前目录下的文件 命令 cd :change directory Node.js是一个轻内核（本身没有什么功能）的东东，所有的功能都要功能包提供 node官方提供了一些最基础的包 1.3.Node用途REPL环境（控制台环境）1.3.1.开发Web应用程序 做动态网站 开发提供数据的服务端API 1.3.2.前端开发工具基础 Node.js给前端乃至整个开发行业带来一场工业革命 刀跟火种 1.4.Node开发Web应用Demo1.4.1.复习请求与响应客户端发送到服务端的东西称之为请求报文服务端返回给客户端的东西称之为响应报文 1.5.NPM1.5.1.什么是NPMhttps://www.npmjs.com/ Node Package Manager Node应用程序依赖包的管理工具 安装卸载更新之类的操作 1.5.2.为什么使用NPM 包很多 场景：我需要用一个A，A依赖B，B依赖C 常见的包管理工具都有循环依赖的功能 你只需记住你要什么东西 1.5.3.常见的NPM操作// 安装一个包，默认安装最新稳定版本npm install package_name// –save// 初始化操作，给项目添加一个配置文件npm init// –yes参数走默认配置 如果官方数据源太慢使用 https://npm.taobao.org/ 2.Bower2.1.什么是Bower 官网 web应用程序依赖项管理工具 2.2.为什么使用Bower 方便便捷的方式管理包，zhuangbi 2.3.Bower实践 npm install -g bower // -g:global 修改npm全局路径，就是在用户目录下添加.npmrc文件 3.Sass/LESS 4.Gulp4.1.Gulp简介 链接： 官网 中文网 就是用来机械化的完成重复性质的工作 gulp的机制就是将重复工作抽象成一个个的任务， 4.2.Gulp准备工作 安装Node.js 安装 gulp 命令行工具 npm install -g gulp 初始化 gulp 项目 创建任务 - gulpfile.js 4.3.基本使用4.4.常用插件 编译 Less：gulp-less 创建本地服务器：gulp-connect 合并文件：gulp-concat 最小化 js 文件：gulp-uglify 重命名文件：gulp-rename 最小化 css 文件：gulp-minify-css 压缩html文件 gulp-minify-html 最小化图像：gulp-imagemin 5.Git5.1.什么是GIT，什么是GITHUB GIT GITHUB 5.2.环境安装5.3.GIT常用命令 6.Markdownhttps://guides.github.com/features/mastering-markdown/https://help.github.com/articles/github-flavored-markdown/https://help.github.com/articles/markdown-basics/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[模块化开发]]></title>
    <url>%2F2018%2F01%2F28%2Fmodule%2F</url>
    <content type="text"><![CDATA[概述什么是模块化开发 将软件产品看作为一系列功能模块的组合 通过特定的方式实现软件所需模块的划分、管理、加载 为什么使用模块化开发 https://github.com/seajs/seajs/issues/547 协同 代码复用 解决问题 大量的文件引入 命名冲突 文件依赖 存在 顺序 实现模块化的推演step-01 全局函数step-02 封装对象step-03 划分私有空间step-04 模块的扩展与维护step-05 第三方依赖管理在什么场景下使用模块化开发 业务复杂 重用逻辑非常多 扩展性要求较高 实现规范CommonJS规范AMD规范 Asynchronous Module Definition 规范 CMD规范 Common Module Definition 规范 实现Seajs使用步骤 在页面中引入sea.js文件 定义一个主模块文件，比如：main.js 在主模块文件中通过define的方式定义一个模块，并导出公共成员 在页面的行内脚本中通过seajs.use(‘path’,fn)的方式使用模块 回调函数的参数传过来的就是模块中导出的成员对象 定义一个模块 define 12345define(function(require, exports, module) &#123; exports.add = function(a, b) &#123; return a + b; &#125;;&#125;); 使用一个模块 seajs.use 一般用于入口模块 一般只会使用一次 require 模块与模块之间 导出成员的方式 module.exports exports.xxx return 三种方式的优先级 异步加载模块 默认require的效果是同步的，会阻塞代码的执行，造成界面卡顿 require.async(); 123require.async('path',function(module) &#123;&#125;); 使用第三方依赖（jQuery） 由于CMD是国产货，jquery默认不支持 改造 12345678// 适配CMDif (typeof define === "function" &amp;&amp; !define.amd) &#123; // 当前有define函数，并且不是AMD的情况 // jquery在新版本中如果使用AMD或CMD方式，不会去往全局挂载jquery对象 define(function() &#123; return jQuery.noConflict(true); &#125;);&#125; Seajs配置 配置 seajs.config base alias]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpacrk入门总结]]></title>
    <url>%2F2017%2F06%2F06%2Fwebpacrk%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[什么是webpack webpakc可以看作是一个模块打包机,可以分析你的项目结构,帮你自动处理一些文件,如压缩、转化等,最终转化为适合浏览器使用的格式。 webpack与gulp工作方式的区别gulp:在一个配置文件中,指明对某些文件进行一些操作(编译,组合,压缩等)步骤之后,这个工具可以自动帮你处理这些文件 工作流程如下 webpack:通过指定的一个入口文件,webpack会从这个文件开始找到你项目所有的依赖文件,使用loaders处理它们,最后打包成一个浏览器可识别的JS(bundle.js)文件 工作流程如下 webpack的使用安装1234//全局安装npm install -g webpack//安装到你的项目目录npm instakk --save-dev webpack 假设项目结构如图所示 执行webpack的几种方法 终端输入 12345webpack entry file(入口文件的位置) bundled file(存放生成的bundle.js的位置) //按上面项目结构走//webpack非全局安装时(全局安装时可省略node_modules/.bin)node_modules/.bin/webpack app/main.js public/bundle.js 通过配置文件来使用webpack 在项目的根目录下建一个名为webpack.config.js的配置文件(本质上是一个JS模块),可以把所有与构建相关的信息放在里面 1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 通过配置package.json文件使用webpack 1234567891011121314&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot;, &quot;comment&quot;: &quot;相当于把npm的start命令指向webpack&quot; &#125;, &quot;author&quot;: &quot;Silence_JK&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^2.6.1&quot; &#125;&#125; 注：package.json中的脚本部分已默认在命令前添加node_modules/.bin,So don’t worry是否在全局安装了webpack webpack的一些常用功能 生成Source Maps(报错时方便调试,google浏览器中setting-&gt;勾选Enalbe JS source map),在wepack的配置文件中配置devtool选项即可 devtoo选项 配置结果 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度； cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项； cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； loaders 通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如将JSON文件转换为JavaScript文件,将下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件,对React的开发而言,合适的Loaders可以把React的JSX文件转换为JS文件。 loaders需要单独安装并且要在webpack.config.js下的module下配置常用配置项包括以下几个: test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 例如:1234567891011121314151617181920212223242526272829//安装可以转换JSON的loadernpm install --save-dev json-loader//配置module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123;//在配置文件里添加JSON loader loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 插件(Plugins)插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins是完全不同的东西 loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个 插件并不直接操作单个文件，它直接对整个构建过程其作用。 Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。 使用插件的方法 要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续看例子，我们添加了一个实现版权声明的插件1234567891011121314151617181920//webpack.config.jsvar webpack = require(&apos;webpack&apos;);module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123;...&#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, plugins: [ new webpack.BannerPlugin(&quot;Copyright Flying Unicorns inc.&quot;)//在这个数组中new一个就可以了 ], devServer: &#123;...&#125;&#125; 查看使用此插件后的JS打包文件localhost:8080/bundle.js 参考文章: 入门webpack,看这篇就够了]]></content>
  </entry>
</search>
